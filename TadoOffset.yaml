# Blueprint migliorato per TadoOffset - versione integrata
# - Mantiene la logica richiesta (arrotondamento 0.1°C; nessun smoothing)
# - Aggiunge persistence, battery_saver/back_off, hysteresis opzionale, controllo impatto su hvac
# - Wait fino a 120s; aggiorna sempre input_datetime ultimo cambio (scelta ii)
# Tutti i commenti sono in italiano per facilitare l'uso e le modifiche.
blueprint:
  name: TadoOffset — avanzato
  description: >
    Blueprint per impostare l'offset delle valvole Tado in base a un sensore esterno.
    Regole principali:
      - calcolo offset tenendo conto dell'offset corrente della valvola (O_new = O_curr + (External - Tado_disp))
      - arrotondamento a 0.1°C (precisione 0.1)
      - cambia offset solo se: diff > tolleranza per modalità, è passato il min_time dall'ultimo cambio,
        offset arrotondato differente da quello attuale, e l'applicazione potrebbe cambiare la richiesta di calore
      - opzione battery_saver con back_off_secs per ridurre i cambi frequenti (batterie)
      - persistence configurabile per i trigger (minuti)
  domain: automation

  input:
    ValvolaRiferimento:
      name: Valvola Tado di riferimento
      description: Entità climate della testa Tado (ogni valvola dovrebbe avere il proprio input_datetime)
      selector:
        entity:
          domain: climate
    TadoTemperature:
      name: Sensore di temperatura Tado
      description: Sensore che riporta la temperatura rilevata dalla testa (incluso l'effetto offset)
      selector:
        entity:
          domain: sensor
    ExternalTemperaure:
      name: Sensore di temperatura Esterno
      description: Sensore di temperatura esterno usato come riferimento
      selector:
        entity:
          domain: sensor
    UltimoCambioOffset:
      name: input_datetime che tiene in memoria l'ultimo cambio offset
      description: input_datetime usato per tracciare l'ultimo cambio per questa valvola (uno per valvola consigliato)
      selector:
        entity:
          domain: input_datetime
    Contatore:
      name: Contatore che incrementa ad ogni tentativo/applicazione offset
      selector:
        entity:
          domain: counter
    TolleranzaHomeHeating:
      name: Tolleranza Home - Heating (°C)
      default: 0.2
      selector:
        number:
          min: 0
          max: 2
          step: 0.1
          unit_of_measurement: "°C"
    TolleranzaHomeOffIdle:
      name: Tolleranza Home - Off/Idle (°C)
      default: 0.4
      selector:
        number:
          min: 0
          max: 2
          step: 0.1
          unit_of_measurement: "°C"
    TolleranzaAway:
      name: Tolleranza Away (°C)
      default: 0.5
      selector:
        number:
          min: 0
          max: 5
          step: 0.1
          unit_of_measurement: "°C"
    MinTimeHomeHeating:
      name: MinTime Home - Heating (secondi)
      description: Intervallo minimo (in secondi) tra due cambi offset in modalità Home+Heating
      default: 300
      selector:
        number:
          min: 0
          max: 60000
          unit_of_measurement: secondi
    MinTimeHomeOffIdle:
      name: MinTime Home - Off / Idle (secondi)
      description: Intervallo minimo (in secondi) tra due cambi offset in modalità Home Off/Idle
      default: 900
      selector:
        number:
          min: 0
          max: 60000
          unit_of_measurement: secondi
    MinTimeAway:
      name: MinTime Away (secondi)
      description: Intervallo minimo (in secondi) tra due cambi offset in modalità Away
      default: 1800
      selector:
        number:
          min: 0
          max: 60000
          unit_of_measurement: secondi
    PersistenceMinutesTarget:
      name: Persistence time Tado (minuti)
      description: Tempo in minuti che lo stato/attributo della valvola deve persistere prima di triggerare
      default: 0.17   # ~10s (valore minimo ragionevole)
      selector:
        number:
          min: 0.17
          max: 60
          step: 0.17
          unit_of_measurement: minuti
    PersistenceMinutesSource:
      name: Persistence time sensore esterno (minuti)
      description: Tempo in minuti che il sensore esterno deve persistere prima di triggerare
      default: 0.17
      selector:
        number:
          min: 0.17
          max: 60
          step: 0.17
          unit_of_measurement: minuti
    battery_saver:
      name: Battery saver
      description: Se true evita cambi frequenti usando back_off_secs e controllo impatto su hvac_action
      default: true
      selector:
        boolean: {}
    back_off_secs:
      name: Back-off (secondi) in modalità battery_saver
      description: Periodo minimo da rispettare dal valore di offset_last_changed prima di consentire nuovo cambiamento
      default: 900
      selector:
        number:
          min: 0
          max: 86400
          unit_of_measurement: secondi
    hysteresis_threshold:
      name: Hysteresis threshold (°C)
      description: Differenza minima tra offset calcolato e offset corrente per applicare (opzionale)
      default: 0.1
      selector:
        number:
          min: 0.0
          max: 1.0
          step: 0.01
          unit_of_measurement: "°C"
    wait_epsilon:
      name: Soglia wait (°C)
      description: soglia piccola usata dal wait_template per considerare l'offset applicato dal device
      default: 0.05
      selector:
        number:
          min: 0.01
          max: 0.2
          step: 0.01
          unit_of_measurement: "°C"

# TRIGGER: manteniamo tutti e tre i trigger con persistence configurabile (in minuti)
trigger:
  - platform: state
    entity_id: !input ValvolaRiferimento
    for:
      minutes: !input PersistenceMinutesTarget
  - platform: state
    entity_id: !input TadoTemperature
    for:
      minutes: !input PersistenceMinutesTarget
  - platform: state
    entity_id: !input ExternalTemperaure
    for:
      minutes: !input PersistenceMinutesSource

condition: []

action:
  - variables:
      # INPUT ENTITIES
      TadoValve: !input ValvolaRiferimento
      TadoTemperatureSensor: !input TadoTemperature
      ExternalSenors: !input ExternalTemperaure
      last_offset_change_entity: !input UltimoCambioOffset
      Counter: !input Contatore

      # CONFIG
      tol_home_heating: !input TolleranzaHomeHeating
      tol_home_offidle: !input TolleranzaHomeOffIdle
      tol_away: !input TolleranzaAway
      min_time_home_heating: !input MinTimeHomeHeating
      min_time_home_offidle: !input MinTimeHomeOffIdle
      min_time_away: !input MinTimeAway
      persistence_target_min: !input PersistenceMinutesTarget
      persistence_source_min: !input PersistenceMinutesSource
      battery_saver_mode: !input battery_saver
      back_off_seconds: !input back_off_secs
      hysteresis: !input hysteresis_threshold
      wait_eps: !input wait_epsilon

      # STATO CORRENTE (raw e arrotondato)
      last_offset_raw: "{{ state_attr(TadoValve, 'offset_celsius') | default(0.0) | float }}"
      last_offset: "{{ (state_attr(TadoValve, 'offset_celsius') | default(0.0) | float) | round(1) }}"
      tado_disp_raw: "{{ states(TadoTemperatureSensor) | float(0) }}"
      tado_disp: "{{ (states(TadoTemperatureSensor) | float(0)) | round(1) }}"
      external_val_raw: "{{ states(ExternalSenors) | float(0) }}"
      external_val: "{{ (states(ExternalSenors) | float(0)) | round(1) }}"
      target_temperature: "{{ state_attr(TadoValve, 'temperature') | float(0) }}"
      hvac_action: "{{ state_attr(TadoValve, 'hvac_action') | string }}"
      preset_mode: "{{ state_attr(TadoValve, 'preset_mode') | string }}"

      # modalita' semplificata
      mode: >-
        {% if (preset_mode == 'home') and (hvac_action == 'heating') %}
          HHe
        {% elif (preset_mode == 'home') and (hvac_action != 'heating') %}
          HOI
        {% elif (preset_mode == 'away') %}
          A
        {% else %}
          ND
        {% endif %}

      # tolleranza e min_time in base alla modalità
      tolerance: >-
        {% if mode == 'HHe' %} {{ tol_home_heating }}
        {% elif mode == 'HOI' %} {{ tol_home_offidle }}
        {% elif mode == 'A' %} {{ tol_away }}
        {% else %} 1.0 {% endif %}

      min_time_between_adjust: >-
        {% if mode == 'HHe' %} {{ min_time_home_heating }}
        {% elif mode == 'HOI' %} {{ min_time_home_offidle }}
        {% elif mode == 'A' %} {{ min_time_away }}
        {% else %} 1 {% endif %}

      # SECONDI dall'ultimo cambiamento (usiamo l'input_datetime passato)
      SecLastadjust: >-
        {{ ((as_timestamp(now()) - as_timestamp(states(last_offset_change_entity))) | int) }}

      # CALCOLO dell'offset secondo la logica: O_new = O_curr + (External - Tado_disp)
      raw_offset_calc: >-
        {{ ( last_offset_raw + (external_val_raw - tado_disp_raw) ) }}
      offset_rounded: "{{ (raw_offset_calc | float) | round(1) }}"
      offset_clamped: >-
        {% set v = offset_rounded | float %}
        {% if v > 10.0 %} 10.0
        {% elif v < -9.9 %} -9.9
        {% else %} {{ v | round(1) }}
        {% endif %}

      # Nuova temperatura percepita dalla valvola dopo l'applicazione dell'offset:
      new_displayed_temp: >-
        {{ (tado_disp_raw - last_offset_raw + offset_clamped | float) | round(1) }}

      # Verifica se il cambiamento impatta la richiesta di calore (utile per battery_saver)
      significant_state_change: >-
        {% set curr_req = (tado_disp_raw < target_temperature) %}
        {% set new_req = ((tado_disp_raw - last_offset_raw + offset_clamped | float) < target_temperature) %}
        {{ curr_req != new_req }}

      # Confronto arrotondato degli offset (scelta A)
      offsets_differ: >-
        {{ ( (last_offset | float) != (offset_clamped | float) ) }}

      # differenza sensori
      external_diff: "{{ (external_val_raw - tado_disp_raw) | round(2) }}"

  # LOG DI DEBUG SINTETICO (disattivare se troppo verboso)
  - service: system_log.write
    data:
      message: >
        [{{ now() }}] TadoOffset trigger: valve={{ TadoValve }} mode={{ mode }} hvac={{ hvac_action }};
        tado={{ tado_disp }} ext={{ external_val }} diff={{ external_diff }};
        tol={{ tolerance }} last_offset={{ last_offset }} new_offset={{ offset_clamped }};
        new_disp={{ new_displayed_temp }} target={{ target_temperature }};
        SecLastadjust={{ SecLastadjust }} min_time={{ min_time_between_adjust }};
        offsets_differ={{ offsets_differ }} significant_state_change={{ significant_state_change }};
        battery_saver={{ battery_saver_mode }} back_off={{ back_off_seconds }}
      level: debug
      logger: blueprints.tado.offset

  # CONDIZIONI: controllo che tutto sia valido e che il cambiamento sia necessario
  - condition: and
    conditions:
      # sensori numerici
      - "{{ is_number(states(ExternalSenors)) }}"
      - "{{ is_number(states(TadoTemperatureSensor)) }}"
      # non agire in away (come da richieste)
      - "{{ preset_mode != 'away' }}"
      # la differenza tra sensore esterno e tado deve superare la tolleranza per la modalità
      - >-
        {{ (external_val_raw - tado_disp_raw) | abs > (tolerance | float) }}
      # è passato almeno min_time dall'ultimo cambio
      - "{{ SecLastadjust > min_time_between_adjust }}"
      # l'offset arrotondato deve essere differente (scelta A)
      - "{{ offsets_differ }}"
      # hysteresis: il cambiamento deve superare la soglia opzionale
      - "{{ (offset_clamped | float - last_offset | float) | abs >= (hysteresis | float) }}"
      # se battery_saver attivo, rispettiamo anche back_off_secs (in aggiunta al SecLastadjust)
      - >-
        {{ ((not battery_saver_mode) or (SecLastadjust > (back_off_seconds | int))) }}
      # se battery_saver attivo, cambiamo solo se l'applicazione impatta la richiesta di calore
      - >-
        {{ ((not battery_saver_mode) or significant_state_change) }}

  # ESEGUI IL SET DELL'OFFSET (solo se tutte le condizioni passano)
  - service: tado.set_climate_temperature_offset
    data:
      entity_id: "{{ TadoValve }}"
      offset: "{{ offset_clamped }}"
    enabled: true

  # Aspettiamo fino a 120s che l'attributo offset_celsius si avvicini al valore richiesto
  - wait_template: >-
      {{ ((state_attr(TadoValve, 'offset_celsius') | float(0) - offset_clamped | float(0)) | abs) < (wait_eps | float(0)) }}
    timeout: "00:02:00"
    continue_on_timeout: true

  # AGGIORNIAMO SEMPRE l'input_datetime ultimo cambio (scelta ii: aggiorniamo comunque)
  - service: input_datetime.set_datetime
    target:
      entity_id: "{{ last_offset_change_entity }}"
    data:
      date_time: "{{ now().strftime('%Y-%m-%d %H:%M:%S') }}"

  # Registro risultato in logbook per audit (utile)
  - service: logbook.log
    data:
      name: "TadoOffset — result"
      message: >
        Valve={{ TadoValve }}; requested_offset={{ offset_clamped }};
        applied_offset={{ state_attr(TadoValve,'offset_celsius') | default('n/a') }};
        achieved={{ ((state_attr(TadoValve,'offset_celsius') | float(0) - offset_clamped | float(0)) | abs) < (wait_eps | float(0)) }};
        new_displayed={{ new_displayed_temp }};
        SecLastadjust_before_update={{ SecLastadjust }}
      entity_id: "{{ TadoValve }}"
      domain: climate

  # Incrementiamo il contatore per tenere traccia dei tentativi/applicazioni
  - service: counter.increment
    target:
      entity_id: "{{ Counter }}"

mode: single
max: 1
